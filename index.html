<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>At HOME Massage & Spa Tracker</title>
    
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- 3. Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- 4. Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- 5. Firebase (Compat Version - CDN for single-file operation) -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

    <!-- 6. Custom Tailwind Config and Styles -->
    <script>
        // Custom Tailwind Configuration to use the Logo's Primary Green (#008000)
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'logo-green': {
                            50: '#E6FFE6',      // Very light background
                            100: '#CCFFCC',     // Light background
                            500: '#00B300',     // Medium
                            600: '#009900',     // Primary Button Hover
                            700: '#008000',     // Base Logo Green / Primary
                            800: '#006600',     // Darker text/header
                            900: '#004C00',     // Deepest text
                        },
                        'teal': {
                            600: '#008080', // Keep some teal accent for contrast
                        }
                    }
                }
            }
        }
    </script>
    <style>
        body { -webkit-tap-highlight-color: transparent; }
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .loader {
            border: 3px solid #f3f3f3;
            border-radius: 50%;
            border-top: 3px solid #008000; /* Use logo-green */
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        .loader-lg {
            width: 48px;
            height: 48px;
            border-width: 5px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">
    
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- CONSTANTS ---
        const BRANCHES = [
            'Guadalupe', 
            'Mabolo', 
            'Talisay', 
            'Bacayan', 
            'Lapu-lapu', 
            'AS Fortuna'
        ];
        
        // --- FIREBASE CONFIGURATION ---
        const MANUAL_FIREBASE_CONFIG = {
            apiKey: "AIzaSyAKXcZwKtFBRFvGbOKd0UnQrLuOLt7wV9M",
            authDomain: "ahmas-tracker.firebaseapp.com",
            projectId: "ahmas-tracker",
            storageBucket: "ahmas-tracker.firebasestorage.app",
            messagingSenderId: "6650730194",
            appId: "1:6650730194:web:eedf9c5bcb25cfe12ebf0b",
            measurementId: "G-XW2GZJXN08"
        };
        
        const firebaseConfig = MANUAL_FIREBASE_CONFIG; 
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;


        // --- ICON COMPONENT ---
        const Icon = ({ name, size = 24, className = "", ...props }) => {
            const wrapperRef = useRef(null);
            useEffect(() => {
                if (!wrapperRef.current) return;
                const tempIcon = document.createElement('i');
                tempIcon.setAttribute('data-lucide', name);
                wrapperRef.current.innerHTML = '';
                wrapperRef.current.appendChild(tempIcon);
                lucide.createIcons({
                    root: wrapperRef.current,
                    nameAttr: 'data-lucide',
                    attrs: { width: size, height: size, class: className, ...props }
                });
            }, [name, size, className]);
            return <span ref={wrapperRef} style={{ display: 'inline-flex', verticalAlign: 'middle' }}></span>;
        };

        const Icons = {
            LayoutDashboard: (p) => <Icon name="layout-dashboard" {...p} />,
            Plus: (p) => <Icon name="plus" {...p} />,
            DollarSign: (p) => <Icon name="dollar-sign" {...p} />,
            Calendar: (p) => <Icon name="calendar" {...p} />,
            CheckCircle2: (p) => <Icon name="check-circle-2" {...p} />,
            Clock: (p) => <Icon name="clock" {...p} />,
            Trash2: (p) => <Icon name="trash-2" {...p} />,
            Users: (p) => <Icon name="users" {...p} />,
            Sparkles: (p) => <Icon name="sparkles" {...p} />,
            Home: (p) => <Icon name="home" {...p} />,
            UserCircle2: (p) => <Icon name="user-circle-2" {...p} />,
            History: (p) => <Icon name="history" {...p} />,
            ChevronDown: (p) => <Icon name="chevron-down" {...p} />,
            ChevronUp: (p) => <Icon name="chevron-up" {...p} />,
            Archive: (p) => <Icon name="archive" {...p} />,
            AlertTriangle: (p) => <Icon name="alert-triangle" {...p} />,
            X: (p) => <Icon name="x" {...p} />,
            Download: (p) => <Icon name="download" {...p} />,
            LogOut: (p) => <Icon name="log-out" {...p} />,
            Lock: (p) => <Icon name="lock" {...p} />,
            ShieldCheck: (p) => <Icon name="shield-check" {...p} />,
            UserPlus: (p) => <Icon name="user-plus" {...p} />,
            User: (p) => <Icon name="user" {...p} />,
            Fingerprint: (p) => <Icon name="fingerprint" {...p} />,
            UserCog: (p) => <Icon name="user-cog" {...p} />,
            Cloud: (p) => <Icon name="cloud" {...p} />,
            WifiOff: (p) => <Icon name="wifi-off" {...p} />,
            Trophy: (p) => <Icon name="trophy" {...p} />,
            MapPin: (p) => <Icon name="map-pin" {...p} />,
            Tag: (p) => <Icon name="tag" {...p} />,
            Hourglass: (p) => <Icon name="hourglass" {...p} />,
            Pencil: (p) => <Icon name="pencil" {...p} />,
            Loader2: (p) => <Icon name="loader-2" {...p} />
        };

        // --- SECURITY HELPER: Hashing Function ---
        const hashPin = async (pin) => {
            if (!pin || pin.length < 4) return null;
            try {
                // Use subtle crypto for SHA-256 hashing
                const msgUint8 = new TextEncoder().encode(pin);
                const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hashHex;
            } catch (error) {
                console.error("Hashing failed:", error);
                return null;
            }
        };

        // --- SECURITY HELPER: Timestamp Normalizer ---
        // Handles both legacy Date.now() numbers and Firestore Timestamp objects
        const getMillis = (ts) => {
            if (!ts) return 0;
            if (typeof ts === 'number') return ts; // Legacy or client-side number
            if (typeof ts.toMillis === 'function') return ts.toMillis(); // Firestore Timestamp object
            if (ts.seconds) return ts.seconds * 1000; // Raw object fallback
            return 0;
        };

        // --- Loading Component ---
        const LoadingOverlay = ({ message }) => (
            <div className="fixed inset-0 z-[60] flex items-center justify-center bg-slate-900/40 backdrop-blur-sm fade-in">
                <div className="bg-white p-6 rounded-2xl shadow-2xl flex flex-col items-center gap-4 min-w-[200px]">
                    <div className="loader loader-lg"></div>
                    <p className="text-slate-600 font-semibold text-sm animate-pulse">{message || 'Processing...'}</p>
                </div>
            </div>
        );


        // --- List Management Component (Admin Only) ---
        const ListManagement = ({ therapists, services, durations, onAdd, onDelete, onEdit }) => {
            const [activeTab, setActiveTab] = useState('therapist'); 
            
            // Add State
            const [newItemName, setNewItemName] = useState('');
            // Service Prices: Map { "60 Mins": 450, "90 Mins": 675 }
            const [newItemPrices, setNewItemPrices] = useState({}); 
            
            // Edit State
            const [editingId, setEditingId] = useState(null);
            const [editName, setEditName] = useState('');
            const [editPrices, setEditPrices] = useState({});

            const [modal, setModal] = useState({ isOpen: false, type: 'confirm', title: '', message: '', onConfirm: null, confirmColor: 'red' });
            const closeModal = () => setModal({ ...modal, isOpen: false });
            
            const handleFormSubmit = (e) => {
                e.preventDefault();
                // Pass extra data (price map) if it's a service
                onAdd(activeTab, newItemName, activeTab === 'service' ? newItemPrices : null);
                setNewItemName('');
                setNewItemPrices({});
            };
            
            const startEdit = (item) => {
                setEditingId(item.id);
                setEditName(item.name);
                setEditPrices(item.prices || {});
            };

            const cancelEdit = () => {
                setEditingId(null);
                setEditName('');
                setEditPrices({});
            };

            const saveEdit = () => {
                const updatedData = { name: editName };
                if (activeTab === 'service') {
                    updatedData.prices = editPrices;
                }
                onEdit(activeTab, editingId, updatedData);
                setEditingId(null);
            };

            const handlePriceChange = (durationName, val, isEdit = false) => {
                const setter = isEdit ? setEditPrices : setNewItemPrices;
                const current = isEdit ? editPrices : newItemPrices;
                
                if (!val) {
                    const copy = { ...current };
                    delete copy[durationName];
                    setter(copy);
                } else {
                    setter({ ...current, [durationName]: parseFloat(val) });
                }
            };

            let currentList = [];
            let placeholderText = "";
            let icon = null;

            if (activeTab === 'therapist') {
                currentList = therapists;
                placeholderText = "Enter Therapist Name";
                icon = <Icons.Users size={18} />;
            } else if (activeTab === 'service') {
                currentList = services;
                placeholderText = "Enter Service Name (e.g. Swedish)";
                icon = <Icons.Tag size={18} />;
            } else {
                currentList = durations;
                placeholderText = "Enter Duration (e.g. 60 Mins)";
                icon = <Icons.Hourglass size={18} />;
            }

            return (
                <div className="space-y-6 fade-in">
                    <h2 className="text-lg font-bold text-logo-green-800 flex gap-2 items-center"><Icons.ShieldCheck size={18} className="text-logo-green-700"/> Master Data Lists</h2>
                    
                    {/* Tabs */}
                    <div className="flex bg-slate-100 p-1 rounded-lg">
                        <button onClick={() => setActiveTab('therapist')} className={`flex-1 py-2 text-xs font-bold rounded-md flex items-center justify-center gap-1 ${activeTab==='therapist' ? 'bg-white shadow-sm text-logo-green-700' : 'text-slate-500'}`}>
                            <Icons.Users size={14}/> Therapists
                        </button>
                        <button onClick={() => setActiveTab('duration')} className={`flex-1 py-2 text-xs font-bold rounded-md flex items-center justify-center gap-1 ${activeTab==='duration' ? 'bg-white shadow-sm text-logo-green-700' : 'text-slate-500'}`}>
                            <Icons.Clock size={14}/> Minutes
                        </button>
                        <button onClick={() => setActiveTab('service')} className={`flex-1 py-2 text-xs font-bold rounded-md flex items-center justify-center gap-1 ${activeTab==='service' ? 'bg-white shadow-sm text-logo-green-700' : 'text-slate-500'}`}>
                            <Icons.Sparkles size={14}/> Services
                        </button>
                    </div>

                    {/* Add New Item */}
                    <div className="bg-white rounded-xl shadow-sm border border-logo-green-100 p-6">
                        <h3 className="font-bold mb-4 flex items-center gap-2 text-sm uppercase tracking-wide text-slate-500"><Icons.Plus size={16}/> Add New {activeTab.charAt(0).toUpperCase() + activeTab.slice(1)}</h3>
                        <form onSubmit={handleFormSubmit} className="flex flex-col gap-3">
                            <div className="flex gap-2">
                                <input 
                                    required 
                                    placeholder={placeholderText} 
                                    value={newItemName} 
                                    onChange={e => setNewItemName(e.target.value)} 
                                    className="flex-1 p-3 border rounded-lg bg-slate-50 focus:ring-2 focus:ring-logo-green-500 outline-none"
                                />
                            </div>
                            
                            {/* Dynamic Price Inputs for Services */}
                            {activeTab === 'service' && (
                                <div className="bg-slate-50 p-3 rounded-lg border border-slate-200">
                                    <p className="text-xs font-bold text-slate-500 mb-2 uppercase">Set Prices per Duration (Optional)</p>
                                    {durations.length === 0 && <p className="text-xs text-red-400 italic">Add items to "Minutes" tab first to set prices.</p>}
                                    <div className="grid grid-cols-2 gap-2">
                                        {durations.map(d => (
                                            <div key={d.id} className="flex items-center gap-2 bg-white p-2 border rounded">
                                                <span className="text-xs font-bold text-slate-600 whitespace-nowrap w-16">{d.name}:</span>
                                                <input 
                                                    type="number" 
                                                    placeholder="Price"
                                                    className="w-full text-sm outline-none"
                                                    value={newItemPrices[d.name] || ''}
                                                    onChange={e => handlePriceChange(d.name, e.target.value, false)}
                                                />
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}

                            <button type="submit" className="w-full bg-logo-green-600 text-white p-3 rounded-lg font-bold hover:bg-logo-green-700 transition shadow-sm">Add to List</button>
                        </form>
                    </div>

                    {/* Current List */}
                    <div className="bg-white rounded-xl shadow-sm border overflow-hidden">
                        <div className="p-4 bg-logo-green-50 font-bold text-logo-green-800 text-sm border-b border-logo-green-100 flex justify-between items-center">
                            <span>Current {activeTab === 'duration' ? 'Durations' : activeTab + 's'} ({currentList.length})</span>
                            {icon}
                        </div>
                        
                        <div className="max-h-[400px] overflow-y-auto">
                            {currentList.length === 0 ? (
                                <p className="text-center text-slate-400 p-6 italic">No items found.</p>
                            ) : (
                                currentList.map(item => (
                                    <div key={item.id} className="p-4 border-b flex flex-col gap-2 last:border-b-0 hover:bg-slate-50">
                                        <div className="flex justify-between items-center w-full">
                                            {editingId === item.id ? (
                                                // Edit Mode Header
                                                <input 
                                                    value={editName}
                                                    onChange={e => setEditName(e.target.value)}
                                                    className="flex-1 p-2 border rounded text-sm bg-white focus:ring-2 focus:ring-logo-green-500 mr-2"
                                                />
                                            ) : (
                                                // View Mode Header
                                                <span className="text-slate-700 font-medium">{item.name}</span>
                                            )}
                                            
                                            {/* Actions */}
                                            <div className="flex gap-1">
                                                {editingId === item.id ? (
                                                    <>
                                                        <button onClick={saveEdit} className="text-logo-green-600 hover:bg-logo-green-50 p-2 rounded transition"><Icons.CheckCircle2 size={18}/></button>
                                                        <button onClick={cancelEdit} className="text-slate-400 hover:bg-slate-100 p-2 rounded transition"><Icons.X size={18}/></button>
                                                    </>
                                                ) : (
                                                    <>
                                                        <button onClick={() => startEdit(item)} className="text-slate-300 hover:text-blue-500 p-2 rounded hover:bg-blue-50 transition" title="Edit Item">
                                                            <Icons.Pencil size={16} />
                                                        </button>
                                                        <button type="button" onClick={() => onDelete(activeTab, item.id, item.name)} className="text-slate-300 hover:text-red-500 p-2 rounded hover:bg-red-50 transition" title="Delete Item">
                                                            <Icons.Trash2 size={16}/>
                                                        </button>
                                                    </>
                                                )}
                                            </div>
                                        </div>

                                        {/* Service Pricing Details (View & Edit) */}
                                        {activeTab === 'service' && (
                                            <div className="text-xs text-slate-500 w-full">
                                                {editingId === item.id ? (
                                                    <div className="grid grid-cols-2 gap-2 mt-2 bg-slate-100 p-2 rounded">
                                                        {durations.map(d => (
                                                            <div key={d.id} className="flex items-center gap-2">
                                                                <span className="font-bold w-14">{d.name}:</span>
                                                                <input 
                                                                    type="number" 
                                                                    className="w-full p-1 border rounded text-xs"
                                                                    placeholder="0"
                                                                    value={editPrices[d.name] || ''}
                                                                    onChange={e => handlePriceChange(d.name, e.target.value, true)}
                                                                />
                                                            </div>
                                                        ))}
                                                    </div>
                                                ) : (
                                                    <div className="flex flex-wrap gap-2 mt-1">
                                                        {item.prices && Object.keys(item.prices).length > 0 ? (
                                                            Object.entries(item.prices).map(([dur, price]) => (
                                                                <span key={dur} className="bg-logo-green-50 text-logo-green-700 px-2 py-0.5 rounded border border-logo-green-100">
                                                                    {dur}: <span className="font-bold">P{price}</span>
                                                                </span>
                                                            ))
                                                        ) : (
                                                            <span className="italic text-slate-300">No specific prices set</span>
                                                        )}
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                ))
                            )}
                        </div>
                    </div>
                      {modal.isOpen && <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-900/60"><div className="bg-white rounded-xl p-6 max-w-sm"><h3 className="font-bold mb-2">{modal.title}</h3><p className="mb-4 text-sm">{modal.message}</p><div className="flex gap-2 justify-end">{modal.type==='confirm'&&<button onClick={closeModal} className="px-4 py-2 text-slate-500">Cancel</button>}<button onClick={modal.onConfirm||closeModal} className={`px-4 py-2 rounded text-white ${modal.confirmColor==='red'?'bg-red-500':'bg-logo-green-600'}`}>Okay</button></div></div></div>}
                </div>
            );
        };

        // --- Admin Reset User Modal ---
        const AdminResetUserModal = ({ editUserModal, setEditUserModal, handleResetPin }) => {
            if (!editUserModal.isOpen || !editUserModal.user) return null;

            const user = editUserModal.user;
            
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4 bg-slate-900/60 fade-in">
                    <div className="bg-white rounded-xl p-6 w-full max-w-sm">
                        <h3 className="text-xl font-bold text-logo-green-800 mb-4 flex items-center gap-2">
                            <Icons.UserCog size={24}/> Reset Staff Credentials
                        </h3>

                        <div className="bg-slate-50 p-4 rounded-lg mb-4">
                            <p className="text-xs text-slate-500 uppercase font-bold">Staff Name:</p>
                            <p className="font-bold text-slate-800 text-lg mb-2">{user.name}</p>

                            <p className="text-xs text-slate-500 uppercase font-bold">Username:</p>
                            <p className="font-mono text-logo-green-700 text-sm">@{user.username}</p>
                        </div>

                        <form onSubmit={handleResetPin} className="space-y-4">
                            <label className="block">
                                <span className="text-sm font-semibold text-slate-700 block mb-1">Set New PIN (4+ Digits)</span>
                                <input
                                    required
                                    type="password"
                                    inputMode="numeric"
                                    maxLength="4"
                                    value={editUserModal.newPin}
                                    onChange={(e) => setEditUserModal({ ...editUserModal, newPin: e.target.value })}
                                    placeholder="Enter new 4-digit PIN"
                                    className="w-full p-3 border rounded-lg font-mono focus:ring-2 focus:ring-logo-green-500"
                                />
                            </label>

                            <div className="flex justify-end gap-2 pt-2">
                                <button 
                                    type="button"
                                    onClick={() => setEditUserModal({ isOpen: false, user: null, newPin: '' })} 
                                    className="px-4 py-2 text-slate-500 rounded hover:bg-slate-100"
                                >
                                    Cancel
                                </button>
                                <button 
                                    type="submit" 
                                    className="px-4 py-2 rounded text-white bg-logo-green-600 hover:bg-logo-green-700 font-bold"
                                >
                                    Reset PIN
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        };


        // --- MAIN APP ---
        const App = () => {
            const [fb, setFb] = useState(null);
            const [fbUser, setFbUser] = useState(null);
            const [isOnline, setIsOnline] = useState(navigator.onLine);
            const [dbReady, setDbReady] = useState(false);
            const [configError, setConfigError] = useState(null); 
            const [isGlobalLoading, setIsGlobalLoading] = useState(false); // NEW: Global Loading State

            const [user, setUser] = useState(null);
            const [users, setUsers] = useState([]);
            const [transactions, setTransactions] = useState([]);
            const [history, setHistory] = useState([]);
            
            // Master Lists
            const [therapistsList, setTherapistsList] = useState([]);
            const [servicesList, setServicesList] = useState([]);
            const [durationsList, setDurationsList] = useState([]);
            
            const [view, setView] = useState('dashboard');
            const [expandedHistoryId, setExpandedHistoryId] = useState(null);
            
            // Staff Accountability State
            const [showMyShift, setShowMyShift] = useState(false);

            // History Filtering State
            const [historyStartDate, setHistoryStartDate] = useState('');
            const [historyEndDate, setHistoryEndDate] = useState('');
            
            // Forms
            const [loginUsername, setLoginUsername] = useState('');
            const [loginPin, setLoginPin] = useState('');
            const [loginBranch, setLoginBranch] = useState(''); 
            
            const [newUser, setNewUser] = useState({ name: '', username: '', pin: '', role: 'staff' });
            const [profileData, setProfileData] = useState({ username: '', pin: '' });
            
            const [formData, setFormData] = useState({
                clientName: '', 
                service: '', 
                therapist: '', 
                amount: '', 
                duration: '', // Added Duration
                type: 'booking', 
                time: new Date().toTimeString().slice(0, 5),
                targetBranch: ''
            });
            const [modal, setModal] = useState({
                isOpen: false, type: 'confirm', title: '', message: '', onConfirm: null, confirmColor: 'red'
            });

            const [editUserModal, setEditUserModal] = useState({ isOpen: false, user: null, newPin: '' });

            const closeModal = () => setModal({ ...modal, isOpen: false });
            const closeEditUserModal = () => setEditUserModal({ isOpen: false, user: null, newPin: '' });


            // --- 1. INITIALIZE FIREBASE ---
            useEffect(() => {
                const initFirebase = async () => {
                    if (!firebaseConfig || !firebaseConfig.projectId) {
                        setConfigError("Firebase configuration is incomplete. Please check the firebaseConfig object.");
                        return;
                    }
                    
                    try {
                        if (!firebase.apps.length) {
                            firebase.initializeApp(firebaseConfig);
                        }
                        
                        const auth = firebase.auth();
                        const db = firebase.firestore();
                        const currentAppId = firebaseConfig.projectId || 'default-app-id';

                        if (initialAuthToken) {
                            await auth.signInWithCustomToken(initialAuthToken);
                        } else {
                            await auth.signInAnonymously();
                        }

                        auth.onAuthStateChanged((u) => {
                            if (u) {
                                setFbUser(u);
                                setFb({ db, auth, appId: currentAppId });
                            }
                        });
                    } catch (error) { 
                        console.error("FB Init Error:", error); 
                        
                        let msg = error.message || "Unknown connection error";
                        
                        if (error.code === 'auth/operation-not-allowed') {
                            msg = "Anonymous Authentication is DISABLED. Please go to Firebase Console -> Authentication -> Sign-in method -> Enable Anonymous.";
                        } else if (error.code === 'auth/unauthorized-domain') {
                            msg = "Domain not authorized. Go to Firebase Console -> Authentication -> Settings -> Authorized Domains and add 'vercel.app' or your custom domain.";
                        }

                        setConfigError(msg); 
                    }
                };

                setTimeout(initFirebase, 500);

                window.addEventListener('online', () => setIsOnline(true));
                window.addEventListener('offline', () => setIsOnline(false));
                return () => {
                    window.removeEventListener('online', () => setIsOnline(true));
                    window.removeEventListener('offline', () => setIsOnline(false));
                };
            }, []);

            // --- 2. DATA SYNC ---
            
            useEffect(() => {
                if (!fb || !fbUser) return;
                const { db, appId } = fb;
                const basePath = `artifacts/${appId}/public/data`;
                
                const getCollection = (name) => db.collection(`${basePath}/${name}`);

                // Transactions
                const unsubTrans = getCollection('transactions')
                    .onSnapshot((snapshot) => {
                        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        // USE HELPER FOR SORTING
                        data.sort((a, b) => getMillis(b.timestamp) - getMillis(a.timestamp));
                        setTransactions(data);
                        setDbReady(true);
                    }, (error) => console.error("Sync Error: Transactions", error));

                // History
                const unsubHistory = getCollection('history')
                    .onSnapshot((snapshot) => {
                        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        // USE HELPER FOR SORTING
                        data.sort((a, b) => getMillis(b.timestamp_val) - getMillis(a.timestamp_val));
                        setHistory(data);
                    }, (error) => console.error("Sync Error: History", error));

                // Users
                const unsubUsers = getCollection('users')
                    .onSnapshot(async (snapshot) => {
                        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        const userColl = getCollection('users');
                        
                        if (data.length === 0) {
                            seedDefaultUsers(db, basePath);
                            return; 
                        }

                        // Check hash updates
                        const needsUpdate = data.filter(u => u.username === 'admin' || u.username === 'morning' || u.username === 'night');
                        let shouldWait = false;
                        for (const u of needsUpdate) {
                            if (u.pin === '8888' || u.pin === '1111' || u.pin === '2222') {
                                const hashedPin = await hashPin(u.pin);
                                await userColl.doc(u.id).update({ pin: hashedPin });
                                shouldWait = true;
                            }
                        }
                        
                        if (!shouldWait) {
                            setUsers(data);
                        }

                    }, (error) => console.error("Sync Error: Users", error));

                // Therapists
                const unsubTherapists = getCollection('therapists')
                    .onSnapshot((snapshot) => {
                        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setTherapistsList(data.sort((a, b) => a.name.localeCompare(b.name)));
                    }, (error) => console.error("Sync Error: Therapists", error));

                // Services
                const unsubServices = getCollection('services')
                    .onSnapshot((snapshot) => {
                        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        setServicesList(data.sort((a, b) => a.name.localeCompare(b.name)));
                    }, (error) => console.error("Sync Error: Services", error));

                // Durations
                const unsubDurations = getCollection('durations')
                    .onSnapshot((snapshot) => {
                        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        
                        // Sort based on numeric value if possible, else string
                        setDurationsList(data.sort((a, b) => {
                            const valA = parseInt(a.name) || 0;
                            const valB = parseInt(b.name) || 0;
                            return valA - valB;
                        }));
                    }, (error) => console.error("Sync Error: Durations", error));


                return () => { 
                    unsubTrans(); 
                    unsubHistory(); 
                    unsubUsers(); 
                    unsubTherapists(); 
                    unsubServices();
                    unsubDurations();
                };
            }, [fb, fbUser]);

            // --- 3. HELPERS ---
            
            const seedDefaultUsers = async (db, basePath) => {
                const defaults = [
                    { name: 'Owner Admin', username: 'admin', pin: '8888', role: 'admin' },
                    { name: 'Morning Rec.', username: 'morning', pin: '1111', role: 'staff' },
                    { name: 'Night Rec.', username: 'night', pin: '2222', role: 'staff' }
                ];
                const userColl = db.collection(`${basePath}/users`);
                const usersToSeed = await Promise.all(defaults.map(async u => {
                    const hashedPin = await hashPin(u.pin);
                    return { ...u, pin: hashedPin }; 
                }));
                for (const u of usersToSeed) await userColl.add(u);
            };

            useEffect(() => {
                if (view === 'profile' && user) {
                    const freshUser = users.find(u => u.id === user.id) || user;
                    setProfileData({ username: freshUser.username, pin: '' }); 
                }
            }, [view, user, users]);

            // Update form data's targetBranch when user or branch changes
            useEffect(() => {
                if (user && formData.targetBranch === '' && user.currentBranch !== 'ALL') {
                    setFormData(prev => ({ ...prev, targetBranch: user.currentBranch }));
                }
            }, [user]);

            const formatCurrency = (val) => {
                if (val === undefined || val === null || val === '') return '';
                return new Intl.NumberFormat('en-PH', { style: 'currency', currency: 'PHP' }).format(val);
            };
            
            // Updated to handle Firestore Timestamps
            const formatDate = (timestamp) => {
                const millis = getMillis(timestamp);
                if (!millis) return 'N/A';
                const date = new Date(millis);
                return date.toLocaleDateString();
            };
            
            // Filter Transactions by Branch AND My Shift Toggle
            const getFilteredData = () => {
                if (!user) return [];
                let data = transactions;

                // 1. Filter by Branch (if not ALL)
                if (user.currentBranch !== 'ALL') {
                    data = data.filter(t => t.branch === user.currentBranch);
                }

                // 2. Filter by User (if My Shift is toggled AND user is staff)
                if (showMyShift && user.role !== 'admin') {
                    data = data.filter(t => t.recordedBy === user.name);
                }
                
                return data;
            };

            const filteredTransactions = getFilteredData();

            const stats = useMemo(() => {
                const data = filteredTransactions;
                const totalRevenue = data.filter(t => t.status === 'completed').reduce((acc, curr) => acc + Number(curr.amount), 0);
                const pendingValue = data.filter(t => t.status === 'pending').reduce((acc, curr) => acc + Number(curr.amount), 0);
                const totalBookings = data.filter(t => t.type === 'booking').length;
                const completedSales = data.filter(t => t.status === 'completed').length;
                return { totalRevenue, pendingValue, totalBookings, completedSales };
            }, [filteredTransactions]);

            // Therapist Stats by Branch
            const therapistStats = useMemo(() => {
                const grouped = {};
                
                filteredTransactions.forEach(t => {
                    const branch = t.branch || (user.currentBranch !== 'ALL' ? user.currentBranch : 'Unknown');
                    const name = t.therapist ? t.therapist.trim() : 'Unassigned';
                    
                    if (!name) return;

                    if (!grouped[branch]) grouped[branch] = {};
                    if (!grouped[branch][name]) grouped[branch][name] = { name, count: 0, amount: 0 };
                    
                    grouped[branch][name].count++;
                    grouped[branch][name].amount += Number(t.amount);
                });

                const result = {};
                Object.keys(grouped).forEach(branch => {
                    result[branch] = Object.values(grouped[branch]).sort((a, b) => b.count - a.count);
                });
                
                return result;
            }, [filteredTransactions, user]);
            
            // Filtered History Logic (for Admin view)
            const filteredHistory = useMemo(() => {
                let data = history;

                if (historyStartDate) {
                    const startTimestamp = new Date(historyStartDate).getTime();
                    data = data.filter(h => getMillis(h.timestamp_val) >= startTimestamp);
                }

                if (historyEndDate) {
                    const endTimestamp = new Date(historyEndDate);
                    endTimestamp.setDate(endTimestamp.getDate() + 1); 
                    const endTimestampVal = endTimestamp.getTime();
                    data = data.filter(h => getMillis(h.timestamp_val) < endTimestampVal);
                }

                return data;
            }, [history, historyStartDate, historyEndDate]);


            const downloadCSV = (record) => {
                const headers = ['Date', 'Branch', 'Time', 'Client Name', 'Service', 'Duration', 'Therapist', 'Amount', 'Status', 'Recorded By'];
                const rows = record.transactions.map(t => [
                    `"${record.date}"`, 
                    `"${t.branch || 'N/A'}"`, 
                    `"${t.time}"`, 
                    `"${t.clientName}"`, 
                    `"${t.service}"`,
                    `"${t.duration || ''}"`, // Added Duration to CSV 
                    `"${t.therapist}"`, 
                    t.amount, 
                    t.status, 
                    `"${t.recordedBy || 'System'}"`
                ]);
                const csvContent = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `AtHome_Report_${record.date.replace(/,/g, '').replace(/ /g, '_')}.csv`;
                link.click();
            };


            // --- 4. ACTIONS ---

            // List Management Handlers
            const handleAddItem = async (listType, itemName, itemPrices = null) => {
                if (!itemName) return;

                const basePath = `artifacts/${fb.appId}/public/data`;
                let collectionName = '';
                let data = { name: itemName.trim() };
                let checkList = [];

                if (listType === 'therapist') {
                    collectionName = 'therapists';
                    checkList = therapistsList;
                } else if (listType === 'service') {
                    collectionName = 'services';
                    checkList = servicesList;
                    if (itemPrices) data.prices = itemPrices; // Store price map
                } else if (listType === 'duration') {
                    collectionName = 'durations';
                    checkList = durationsList;
                } else {
                    return;
                }
                
                if (checkList.some(item => item.name.toLowerCase() === itemName.trim().toLowerCase())) {
                    setModal({ isOpen: true, type: 'alert', title: 'Duplicate Item', message: `${itemName} already exists in ${listType}s.`, onConfirm: closeModal, confirmColor: 'red' });
                    return;
                }

                setIsGlobalLoading(true);
                try {
                    await fb.db.collection(`${basePath}/${collectionName}`).add(data);
                } catch (err) {
                    setModal({ isOpen: true, type: 'alert', title: 'Error', message: 'Failed to add item.', confirmColor: 'red', onConfirm: closeModal });
                } finally {
                    setIsGlobalLoading(false);
                }
            };

            const handleDeleteItem = (listType, id, name) => {
                let collectionName = '';
                if (listType === 'therapist') collectionName = 'therapists';
                else if (listType === 'service') collectionName = 'services';
                else if (listType === 'duration') collectionName = 'durations';
                else return;

                const basePath = `artifacts/${fb.appId}/public/data`;
                
                setModal({
                    isOpen: true, type: 'confirm', title: `Delete ${listType}?`, message: `Are you sure you want to permanently delete "${name}"?`, confirmColor: 'red',
                    onConfirm: async () => {
                        closeModal(); // Close confirm modal first
                        setIsGlobalLoading(true);
                        try {
                            await fb.db.collection(`${basePath}/${collectionName}`).doc(id).delete();
                        } catch (error) {
                            setModal({ isOpen: true, type: 'alert', title: 'Error', message: 'Deletion failed.', confirmColor: 'red', onConfirm: closeModal });
                        } finally {
                            setIsGlobalLoading(false);
                        }
                    }
                });
            };

            const handleEditItem = async (listType, id, updatedData) => {
                let collectionName = '';
                if (listType === 'therapist') collectionName = 'therapists';
                else if (listType === 'service') collectionName = 'services';
                else if (listType === 'duration') collectionName = 'durations';
                else return;

                const basePath = `artifacts/${fb.appId}/public/data`;
                setIsGlobalLoading(true);
                try {
                    await fb.db.collection(`${basePath}/${collectionName}`).doc(id).update(updatedData);
                    setModal({ isOpen: true, type: 'alert', title: 'Success', message: 'Item updated successfully.', onConfirm: closeModal, confirmColor: 'logo-green' });
                } catch (error) {
                    console.error("Update error:", error);
                    setModal({ isOpen: true, type: 'alert', title: 'Error', message: 'Failed to update item.', onConfirm: closeModal, confirmColor: 'red' });
                } finally {
                    setIsGlobalLoading(false);
                }
            };

            // History Deletion Handler (Admin Only)
            const handleDeleteHistory = (id, date) => {
                if (user?.role !== 'admin') return;

                 setModal({
                    isOpen: true, type: 'confirm', title: `Delete Report?`, message: `Are you sure you want to permanently delete the archived report for ${date}? This action cannot be undone.`, confirmColor: 'red',
                    onConfirm: async () => {
                        closeModal();
                        setIsGlobalLoading(true);
                        try {
                            const basePath = `artifacts/${fb.appId}/public/data`;
                            await fb.db.collection(`${basePath}/history`).doc(id).delete();
                        } catch (err) {
                            setModal({ isOpen: true, type: 'alert', title: 'Error', message: 'Could not delete history.', confirmColor: 'red', onConfirm: closeModal });
                        } finally {
                            setIsGlobalLoading(false);
                        }
                    }
                });
            };
            

            const handleLoginSubmit = async (e) => {
                e.preventDefault();
                if (!loginBranch) {
                    setModal({ isOpen: true, type: 'alert', title: 'Branch Required', message: 'Please select your branch location.', onConfirm: closeModal, confirmColor: 'red' });
                    return;
                }
                
                setIsGlobalLoading(true);
                try {
                    const hashedPinAttempt = await hashPin(loginPin);
                    if (!hashedPinAttempt) {
                        setModal({ isOpen: true, type: 'alert', title: 'Login Error', message: 'PIN must be at least 4 digits.', onConfirm: closeModal, confirmColor: 'red' });
                        return;
                    }

                    const found = users.find(u => u.username.toLowerCase() === loginUsername.toLowerCase() && u.pin === hashedPinAttempt);
                    
                    if (found) {
                        setUser({ ...found, currentBranch: loginBranch });
                        setLoginUsername(''); setLoginPin(''); setLoginBranch(''); setView('dashboard');
                    } else {
                        setModal({ isOpen: true, type: 'alert', title: 'Login Failed', message: 'Check credentials.', onConfirm: closeModal, confirmColor: 'red' });
                    }
                } catch (err) {
                    setModal({ isOpen: true, type: 'alert', title: 'Error', message: 'Login processing error.', onConfirm: closeModal, confirmColor: 'red' });
                } finally {
                    setIsGlobalLoading(false);
                }
            };

            // HELPER: Calculate Price
            const calculatePrice = (serviceName, durationName) => {
                if (!serviceName) return '';
                
                const foundService = servicesList.find(s => s.name === serviceName);
                if (!foundService) return '';

                // 1. Try to find exact duration price
                if (durationName && foundService.prices && foundService.prices[durationName]) {
                    return foundService.prices[durationName];
                } 
                
                // 2. Fallback to base price (if any legacy price exists)
                if (foundService.price) {
                    return foundService.price;
                }

                return '';
            };

            const handleServiceChange = (serviceName) => {
                // Calculate price based on this NEW service + EXISTING duration
                const newPrice = calculatePrice(serviceName, formData.duration);
                
                setFormData({ 
                    ...formData, 
                    service: serviceName,
                    amount: newPrice 
                });
            };

            const handleDurationChange = (durationName) => {
                // Calculate price based on EXISTING service + NEW duration
                const newPrice = calculatePrice(formData.service, durationName);

                setFormData({ 
                    ...formData, 
                    duration: durationName,
                    amount: newPrice 
                });
            };

            const handleSubmit = async (e) => {
                e.preventDefault();
                const transactionBranch = user.currentBranch === 'ALL' ? formData.targetBranch : user.currentBranch;

                if (!formData.clientName || !formData.amount || !formData.service || !formData.therapist) {
                    setModal({ isOpen: true, type: 'alert', title: 'Missing Information', message: 'Please ensure Client Name, Service, Therapist, and Price are all entered.', onConfirm: closeModal, confirmColor: 'red' });
                    return;
                }
                
                if (user.currentBranch === 'ALL' && !formData.targetBranch) {
                    setModal({ isOpen: true, type: 'alert', title: 'Missing Branch', message: 'Please select a Target Branch for this booking.', onConfirm: closeModal, confirmColor: 'red' });
                    return;
                }

                setIsGlobalLoading(true);
                try {
                    const basePath = `artifacts/${fb.appId}/public/data`;
                    await fb.db.collection(`${basePath}/transactions`).add({
                        ...formData,
                        amount: parseFloat(formData.amount),
                        status: formData.type === 'sale' ? 'completed' : 'pending',
                        recordedBy: user.name,
                        branch: transactionBranch, 
                        // SECURE: Use Server Timestamp instead of Client Date
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    const resetTargetBranch = user.currentBranch === 'ALL' ? transactionBranch : user.currentBranch;
                    
                    setFormData({ 
                        clientName: '', 
                        service: '', 
                        duration: '',
                        therapist: '', 
                        amount: '', 
                        type: 'booking', 
                        time: new Date().toTimeString().slice(0, 5),
                        targetBranch: resetTargetBranch
                    });
                    
                    setModal({ isOpen: true, type: 'alert', title: 'Booking Saved!', message: `${formData.clientName} recorded for ${transactionBranch}.`, onConfirm: closeModal, confirmColor: 'logo-green' });

                    setView('dashboard');
                } catch (error) {
                    setModal({ isOpen: true, type: 'alert', title: 'Error', message: 'Failed to save booking. Please check connection.', onConfirm: closeModal, confirmColor: 'red' });
                } finally {
                    setIsGlobalLoading(false);
                }
            };

            const toggleStatus = async (t) => {
                const basePath = `artifacts/${fb.appId}/public/data`;
                const newStatus = t.status === 'pending' ? 'completed' : 'pending';
                // Optimistic or silent update is usually fine here, but let's wrap for safety if requested
                setIsGlobalLoading(true);
                try {
                    await fb.db.collection(`${basePath}/transactions`).doc(t.id).update({ status: newStatus });
                } catch(err) {
                    console.error("Status toggle failed");
                } finally {
                    setIsGlobalLoading(false);
                }
            };

            const requestDelete = (id) => {
                if (user?.role !== 'admin') {
                    setModal({ isOpen: true, type: 'alert', title: 'Access Denied', message: 'Only Admin can delete.', onConfirm: closeModal, confirmColor: 'red' });
                    return;
                }
                setModal({
                    isOpen: true, type: 'confirm', title: 'Delete Record?', message: 'Permanently remove from cloud?', confirmColor: 'red',
                    onConfirm: async () => {
                        closeModal();
                        setIsGlobalLoading(true);
                        try {
                            const basePath = `artifacts/${fb.appId}/public/data`;
                            await fb.db.collection(`${basePath}/transactions`).doc(id).delete();
                        } catch(err) {
                            setModal({ isOpen: true, type: 'alert', title: 'Error', message: 'Delete failed.', confirmColor: 'red', onConfirm: closeModal });
                        } finally {
                            setIsGlobalLoading(false);
                        }
                    }
                });
            };

            const requestEndDay = () => {
                if (user?.role !== 'admin') {
                    setModal({ isOpen: true, type: 'alert', title: 'Access Denied', message: 'Only Admin can close the day.', onConfirm: closeModal, confirmColor: 'red' });
                    return;
                }
                if (filteredTransactions.length === 0) {
                    setModal({ isOpen: true, type: 'alert', title: 'No Data', message: 'Nothing to save for this branch.', onConfirm: closeModal, confirmColor: 'logo-green' });
                    return;
                }

                setModal({
                    isOpen: true, type: 'confirm', title: 'End Day & Sync?', message: `Save ${user.currentBranch} report to history and clear board?`, confirmColor: 'logo-green',
                    onConfirm: async () => {
                        closeModal();
                        setIsGlobalLoading(true);
                        try {
                            const basePath = `artifacts/${fb.appId}/public/data`;
                            const historyColl = fb.db.collection(`${basePath}/history`);
                            const transColl = fb.db.collection(`${basePath}/transactions`);

                            await historyColl.add({
                                date: new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }),
                                timestamp: new Date().toLocaleString(),
                                // SECURE: Use Server Timestamp
                                timestamp_val: firebase.firestore.FieldValue.serverTimestamp(),
                                transactions: filteredTransactions,
                                stats: stats,
                                branch: user.currentBranch,
                                closedBy: user.name
                            });

                            const deletePromises = filteredTransactions.map(t => transColl.doc(t.id).delete());
                            await Promise.all(deletePromises);

                            setView('history');
                        } catch (err) {
                            setModal({ isOpen: true, type: 'alert', title: 'Error', message: 'Failed to end day. Data preserved.', confirmColor: 'red', onConfirm: closeModal });
                        } finally {
                            setIsGlobalLoading(false);
                        }
                    }
                });
            };
